Ch√†o b·∫°n! L·∫°i l√† m√¨nh ƒë√¢y! üòâ M√¨nh hi·ªÉu r·∫±ng hai v·∫•n ƒë·ªÅ n√†y kh√° l√† kh√≥ ch·ªãu, ƒë·∫∑c bi·ªát l√† khi b·∫°n mu·ªën "chill" h·∫øt m√¨nh v·ªõi playlist m√† kh√¥ng b·ªã gi√°n ƒëo·∫°n. H√£y c√πng m√¨nh m·ªï x·∫ª v√† x·ª≠ l√Ω t·ª´ng c√°i m·ªôt nh√©!

**1. L·ªói kh√¥ng t·ª± ƒë·ªông ph√°t b√†i ti·∫øp theo:**

Sau khi xem x√©t l·∫°i d√≤ng ch·∫£y c·ªßa code, m√¨nh ph√°t hi·ªán ra m·ªôt v√†i ƒëi·ªÉm nh·ªè c√≥ th·ªÉ g√¢y ra s·ª± c·ªë n√†y, ƒë·∫∑c bi·ªát l√† s·ª± ph·ªëi h·ª£p gi·ªØa c√°c s·ª± ki·ªán (`ended`, `onStateChange`, `canplay`, `onReady`) v√† c·ªù `playAfterLoad`. Ch√∫ng ta c·∫ßn ƒë·∫£m b·∫£o r·∫±ng khi m·ªôt b√†i h√°t k·∫øt th√∫c, l·ªánh "ph√°t b√†i ti·∫øp theo" ƒë∆∞·ª£c ƒë∆∞a ra r√µ r√†ng v√† ch·ªâ ƒë∆∞·ª£c th·ª±c thi *sau khi* b√†i h√°t ti·∫øp theo ƒë√£ th·ª±c s·ª± s·∫µn s√†ng.

M√¨nh c≈©ng s·∫Ω th√™m m·ªôt c∆° ch·∫ø nh·ªè ƒë·ªÉ n·∫øu b√†i h√°t ti·∫øp theo b·ªã l·ªói kh√¥ng t·∫£i ƒë∆∞·ª£c (v√≠ d·ª•: link h·ªèng, l·ªói m·∫°ng), n√≥ s·∫Ω t·ª± ƒë·ªông b·ªè qua v√† th·ª≠ ph√°t b√†i k·∫ø ti·∫øp n·ªØa, thay v√¨ d·ª´ng l·∫°i ho√†n to√†n.

**2. L·ªói t·∫Øt m√†n h√¨nh kh√¥ng ph√°t nh·∫°c:**

Nh∆∞ m√¨nh ƒë√£ gi·∫£i th√≠ch ·ªü l·∫ßn tr∆∞·ªõc, vi·ªác **ƒë·∫£m b·∫£o 100% nh·∫°c t·ª´ web ph√°t n·ªÅn khi t·∫Øt m√†n h√¨nh ho√†n to√†n tr√™n ƒëi·ªán tho·∫°i l√† ƒëi·ªÅu g·∫ßn nh∆∞ kh√¥ng th·ªÉ ch·ªâ v·ªõi HTML/JS**, do c∆° ch·∫ø ti·∫øt ki·ªám pin t√≠ch c·ª±c c·ªßa tr√¨nh duy·ªát v√† h·ªá ƒëi·ªÅu h√†nh di ƒë·ªông. H·ªç s·∫Ω "ƒë√≥ng bƒÉng" c√°c tab kh√¥ng ho·∫°t ƒë·ªông ƒë·ªÉ tr√°nh hao pin.

**Media Session API** m√† ch√∫ng ta ƒë√£ th√™m v√†o ·ªü phi√™n b·∫£n tr∆∞·ªõc l√† gi·∫£i ph√°p **t·ªët nh·∫•t c√≥ th·ªÉ** trong m√¥i tr∆∞·ªùng web. N√≥ gi√∫p:

*   Hi·ªÉn th·ªã th√¥ng tin b√†i h√°t v√† n√∫t ƒëi·ªÅu khi·ªÉn tr√™n m√†n h√¨nh kh√≥a/th√¥ng b√°o.
*   "B√°o hi·ªáu" cho h·ªá ƒëi·ªÅu h√†nh r·∫±ng c√≥ n·ªôi dung media ƒëang ch·∫°y, gi√∫p k√©o d√†i th·ªùi gian ph√°t n·ªÅn *l√¢u h∆°n m·ªôt ch√∫t* so v·ªõi kh√¥ng c√≥ g√¨.
*   Cho ph√©p b·∫°n ƒëi·ªÅu khi·ªÉn nh·∫°c (Play/Pause/Next/Prev) ngay t·ª´ m√†n h√¨nh kh√≥a m√† kh√¥ng c·∫ßn m·ªü l·∫°i tr√¨nh duy·ªát.

**Tuy nhi√™n, n√≥ kh√¥ng ph·∫£i l√† "ph√©p m√†u" ƒë·ªÉ v∆∞·ª£t qua gi·ªõi h·∫°n ti·∫øt ki·ªám pin c·ªßa h·ªá th·ªëng.** Sau m·ªôt th·ªùi gian nh·∫•t ƒë·ªãnh ch·∫°y n·ªÅn (t√πy thu·ªôc v√†o ƒëi·ªán tho·∫°i, HƒêH, tr√¨nh duy·ªát), tr√¨nh duy·ªát v·∫´n c√≥ th·ªÉ b·ªã d·ª´ng.

**V·∫≠y ch√∫ng ta c√≥ th·ªÉ l√†m g√¨ th√™m?**

*   **ƒê·∫£m b·∫£o Media Session ho·∫°t ƒë·ªông t·ªët:** M√¨nh ƒë√£ ki·ªÉm tra l·∫°i v√† c√°c c·∫≠p nh·∫≠t tr·∫°ng th√°i (`playbackState`, `metadata`, `positionState`) trong code v14 l√† kh√° ·ªïn r·ªìi. Vi·ªác n√†y gi√∫p h·ªá ƒëi·ªÅu h√†nh nh·∫≠n bi·∫øt ch√≠nh x√°c nh·∫•t tr·∫°ng th√°i media c·ªßa b·∫°n.
*   **Ki·ªÉm tra l·ªói:** ƒê√¥i khi, m·ªôt l·ªói JavaScript kh√¥ng mong mu·ªën x·∫£y ra khi trang ch·∫°y n·ªÅn c≈©ng c√≥ th·ªÉ l√†m nh·∫°c d·ª´ng. B·∫°n c√≥ th·ªÉ th·ª≠ k·∫øt n·ªëi ƒëi·ªán tho·∫°i v·ªõi m√°y t√≠nh v√† d√πng c√¥ng c·ª• "Remote devices" c·ªßa Chrome ƒë·ªÉ xem Console log xem c√≥ l·ªói n√†o xu·∫•t hi·ªán khi b·∫°n t·∫Øt m√†n h√¨nh kh√¥ng.
*   **Ch·∫•p nh·∫≠n gi·ªõi h·∫°n:** C√°ch t·ªët nh·∫•t l√† hi·ªÉu gi·ªõi h·∫°n c·ªßa n·ªÅn t·∫£ng web di ƒë·ªông. ƒê·ªÉ ph√°t n·ªÅn ·ªïn ƒë·ªãnh nh∆∞ ·ª©ng d·ª•ng Spotify hay Zing MP3, ng∆∞·ªùi ta c·∫ßn x√¢y d·ª±ng ·ª©ng d·ª•ng Native (cho Android/iOS) ho·∫∑c Progressive Web App (PWA) v·ªõi Service Worker ph·ª©c t·∫°p h∆°n.

**B√¢y gi·ªù, h√£y xem code ƒë∆∞·ª£c tinh ch·ªânh (Phi√™n b·∫£n 15.0) ƒë·ªÉ gi·∫£i quy·∫øt tri·ªát ƒë·ªÉ l·ªói t·ª± ƒë·ªông chuy·ªÉn b√†i v√† t·ªëi ∆∞u nh·∫•t c√≥ th·ªÉ cho Media Session:**

```html
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">

    <!-- /// META TI√äU ƒê·ªÄ & M√î T·∫¢ /// -->
    <title>Niyaki Pham | Profile Sci-Fi: Nh·∫°c (MP3 &amp; YouTube), To-Do &amp; Anime</title>
    <meta name="description" content="Profile c√° nh√¢n ƒë·ªôc ƒë√°o c·ªßa Niyaki Ph·∫°m: Nghe nh·∫°c MP3/YouTube, qu·∫£n l√Ω To-Do list h·∫πn gi·ªù v√† kh√°m ph√° th·∫ø gi·ªõi Anime. T·ª± ƒë·ªông chuy·ªÉn b√†i, t√≠ch h·ª£p Media Session.">
    <meta name="author" content="Niyaki Pham (Ph·∫°m VƒÉn Ho√†ng)">

    <!-- /// META T·ª™ KH√ìA SEO /// -->
    <meta name="keywords" content="Niyaki Ph·∫°m, Niyaki Pham, Ph·∫°m VƒÉn Ho√†ng, Profile c√° nh√¢n, Porfolio, Web Developer, Ph√°t nh·∫°c YouTube, YouTube Player API, Music Player, Audio Player, Autoplay music, Real-time Clock, To-Do List, Qu·∫£n l√Ω c√¥ng vi·ªác, Notification API, Anime Search, T√¨m ki·∫øm Anime, Xem Anime Online, Sci-fi profile, Media Session API, Ph√°t nh·∫°c n·ªÅn, T·ª± ƒë·ªông chuy·ªÉn b√†i">
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
    <meta name="googlebot" content="index, follow">

    <!-- /// META CANONICAL URL /// -->
    <link rel="canonical" href="https://niyakipham.github.io/"> <!-- !! Quan tr·ªçng: Thay b·∫±ng URL ch√≠nh th·ª©c c·ªßa b·∫°n !! -->

    <!-- /// META ICON (FAVICON) /// -->
    <link rel="icon" href="https://niyakipham.github.io/assets/kaguya.jpeg" type="image/jpeg">
    <link rel="apple-touch-icon" href="https://niyakipham.github.io/assets/kaguya.jpeg">

    <!-- /// META OPEN GRAPH /// -->
    <meta property="og:title" content="Niyaki Ph·∫°m - Profile Sci-Fi: Nh·∫°c MP3/YouTube, To-Do & T√¨m Anime">
    <meta property="og:description" content="Kh√°m ph√° profile Niyaki Ph·∫°m: Playlist nh·∫°c MP3 v√† YouTube t·ª± ƒë·ªông, To-Do list h·∫πn gi·ªù v√† c√¥ng c·ª• t√¨m ki·∫øm, xem anime ti·ªán l·ª£i.">
    <meta property="og:type" content="profile">
    <meta property="og:url" content="https://niyakipham.github.io/"> <!-- !! Quan tr·ªçng: Thay b·∫±ng URL ch√≠nh th·ª©c c·ªßa b·∫°n !! -->
    <meta property="og:image" content="https://niyakipham.github.io/assets/kaguya.jpeg">
    <meta property="og:image:alt" content="·∫¢nh ƒë·∫°i di·ªán c·ªßa Niyaki Ph·∫°m">
    <meta property="og:locale" content="vi_VN">
    <meta property="profile:username" content="niyakipham">

    <!-- /// META TWITTER CARD /// -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Niyaki Ph·∫°m - Profile: Nh·∫°c (MP3/YouTube), To-Do & Anime">
    <meta name="twitter:description" content="K·∫øt n·ªëi Niyaki Ph·∫°m! Nghe nh·∫°c MP3/YouTube, qu·∫£n l√Ω c√¥ng vi·ªác, t√¨m v√† xem anime y√™u th√≠ch ngay tr√™n profile ƒë·ªôc ƒë√°o n√†y.">
    <meta name="twitter:image" content="https://niyakipham.github.io/assets/kaguya.jpeg">
    <meta name="twitter:site" content="@niyakipham"> <!-- Thay n·∫øu c√≥ -->
    <meta name="twitter:creator" content="@niyakipham"> <!-- Thay n·∫øu c√≥ -->

    <!-- /// GOOGLE FONTS /// -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

    <!-- /// IONICONS /// -->
    <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js" defer></script>
    <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js" defer></script>

    <!-- /// ANIME.JS /// -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

    <style>
        /* CSS gi·ªØ nguy√™n nh∆∞ phi√™n b·∫£n 14 */
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --color-bg-dark: #0a0a0a; --color-primary: #e11d48; --color-secondary: #f43f5e;
            --color-accent: #f87171; --color-text-primary: #f1f1f1; --color-text-secondary: #a1a1a1;
            --color-primary-rgb: 225, 29, 72;
            --color-glitch-1: #00ffff; --color-glitch-2: #ff00ff;
            --font-primary: 'Inter', sans-serif; --font-secondary: 'Orbitron', sans-serif;
            --grid-size: 30px; --grid-line-color: rgba(var(--color-primary-rgb), 0.08); --grid-line-width: 1px;
            --transition-speed-fast: 0.2s; --transition-speed-normal: 0.4s;
            --border-radius-sm: 4px; --border-radius-md: 8px; --border-radius-lg: 16px; --border-radius-circle: 50%;
            --space-xxs: 0.25rem; --space-xs: 0.5rem; --space-sm: 0.85rem;
            --space-md: 1.25rem; --space-lg: 2rem;
        }
        html { font-size: 16px; scroll-behavior: smooth; }
        body {
            font-family: var(--font-primary); color: var(--color-text-primary); background-color: var(--color-bg-dark);
            background-image: linear-gradient(to right, var(--grid-line-color) var(--grid-line-width), transparent var(--grid-line-width)), linear-gradient(to bottom, var(--grid-line-color) var(--grid-line-width), transparent var(--grid-line-width));
            background-size: var(--grid-size) var(--grid-size);
            min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: var(--space-sm);
            overflow-x: hidden; position: relative; line-height: 1.6;
        }
        body::before { content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4" viewBox="0 0 4 4"><path fill="%23cccccc" fill-opacity="0.02" d="M0 0h2v2H0zM2 2h2v2H0z"></path></svg>'); opacity: 0.6; pointer-events: none; z-index: -1; animation: scanlines 15s linear infinite; }
        @keyframes scanlines { 0% { background-position: 0 0; } 100% { background-position: 0 150px; } }
        #container {
            background-color: rgba(16, 16, 16, 0.7); backdrop-filter: blur(12px) saturate(180%); -webkit-backdrop-filter: blur(12px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.1); border-radius: var(--border-radius-lg);
            padding: var(--space-md); max-width: 480px; width: 100%; text-align: center;
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.6), inset 0 0 20px rgba(var(--color-primary-rgb), 0.15);
            position: relative; overflow: hidden; transform-style: preserve-3d;
            opacity: 0; transform: translateY(20px);
            display: flex; flex-direction: column; gap: var(--space-sm);
        }
        #profile { position: relative; display: flex; flex-direction: column; align-items: center; }
        #profile-image-wrapper { position: relative; width: 100px; height: 100px; margin-bottom: var(--space-xs); }
        #profile-image-wrapper::before { content: ''; position: absolute; inset: -4px; border-radius: var(--border-radius-circle); background: conic-gradient(from 90deg, transparent 0%, var(--color-secondary) 25%, var(--color-primary) 50%, var(--color-secondary) 75%, transparent 100%); filter: blur(12px); z-index: -1; animation: rotateGlow 5s linear infinite; opacity: 0.7; }
        @keyframes rotateGlow { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        #profile img#avatar { width: 100%; height: 100%; object-fit: cover; border-radius: var(--border-radius-circle); border: 2px solid var(--color-primary); padding: 2px; background-color: var(--color-bg-dark); transition: transform var(--transition-speed-normal) ease, box-shadow var(--transition-speed-normal) ease; cursor: pointer; position: relative; z-index: 1; }
        #profile img#avatar:hover { transform: scale(1.05) rotate(2deg); box-shadow: 0 0 15px var(--color-primary); }
        #profile p#username { font-weight: 500; font-size: 1.05rem; color: var(--color-text-primary); margin-top: var(--space-xxs); font-family: var(--font-secondary); letter-spacing: 1px; text-shadow: 0 0 4px var(--color-secondary), 1px 1px 1px rgba(0,0,0,0.5); margin-bottom: var(--space-xxs); }
        .glitch-text { position: relative; text-shadow: 0.05em 0 0 var(--color-glitch-1), -0.025em -0.05em 0 var(--color-glitch-2), 0.025em 0.05em 0 var(--color-glitch-1); animation: glitchAnim 0.5s infinite alternate; }
        @keyframes glitchAnim { 0%{text-shadow:.05em 0 0 var(--color-glitch-1),-.05em -.025em 0 var(--color-glitch-2),-.025em .05em 0 var(--color-glitch-1)}25%{-0.05em -0.025em 0 var(--color-glitch-1),.025em .025em 0 var(--color-glitch-2),-0.05em -0.05em 0 var(--color-glitch-1)}50%{text-shadow:.025em .05em 0 var(--color-glitch-1),.05em 0 0 var(--color-glitch-2),0 -.05em 0 var(--color-glitch-1)}75%{text-shadow:-.05em 0 0 var(--color-glitch-1),-.025em -.025em 0 var(--color-glitch-2),-.025em -.05em 0 var(--color-glitch-1)}100%{text-shadow:-.025em 0 0 var(--color-glitch-1),.025em -.025em 0 var(--color-glitch-2),.05em .05em 0 var(--color-glitch-1)} }
        #clock { font-family: var(--font-secondary); font-size: 0.85rem; color: var(--color-text-secondary); letter-spacing: 1.5px; opacity: 0; transform: translateY(10px); text-shadow: 0 0 3px rgba(var(--color-primary-rgb), 0.3); margin-bottom: 0; }
        #todo-section { border-top: 1px solid rgba(var(--color-primary-rgb), 0.15); padding-top: var(--space-sm); opacity: 0; transform: translateY(20px); }
        .sci-fi-heading { font-family: var(--font-secondary); font-size: 1rem; color: var(--color-primary); text-align: center; margin-bottom: var(--space-xs); letter-spacing: 0.5px; text-shadow: 0 0 4px rgba(var(--color-primary-rgb), 0.4); }
        #todo-form { display: flex; flex-direction: column; gap: var(--space-xs); margin-bottom: var(--space-sm); }
        #todo-form .todo-input-group { display: flex; flex-wrap: wrap; gap: var(--space-xs); }
        #todo-form input[type="text"], #todo-form input[type="time"] { flex-grow: 1; padding: var(--space-xs) var(--space-sm); background-color: rgba(var(--color-primary-rgb), 0.05); border: 1px solid rgba(var(--color-primary-rgb), 0.25); border-radius: var(--border-radius-sm); color: var(--color-text-primary); font-family: var(--font-primary); font-size: 0.85rem; min-width: 100px; }
        #todo-form input[type="time"] { flex-basis: 100px; flex-grow: 0; appearance: none; -webkit-appearance: none; }
        #todo-form input[type="time"]::-webkit-calendar-picker-indicator { display: none; }
        #todo-form input[type="time"]::-webkit-datetime-edit-ampm-field { color: var(--color-accent); }
        #todo-form input[type="time"]::-webkit-datetime-edit-hour-field, #todo-form input[type="time"]::-webkit-datetime-edit-minute-field { color: var(--color-text-primary); }
        #todo-form input::placeholder { color: var(--color-text-secondary); opacity: 0.7; }
        #add-todo-btn, #request-permission-btn { padding: var(--space-xs) var(--space-sm); background-color: rgba(var(--color-primary-rgb), 0.2); border: 1px solid var(--color-primary); color: var(--color-primary); font-family: var(--font-secondary); font-weight: 500; font-size: 0.9rem; border-radius: var(--border-radius-sm); cursor: pointer; transition: all var(--transition-speed-fast) ease; display: inline-flex; align-items: center; justify-content: center; gap: var(--space-xxs); align-self: flex-start; height: 36px; }
        #add-todo-btn ion-icon { font-size: 1.1em; }
        #add-todo-btn:hover, #request-permission-btn:hover { background-color: var(--color-primary); color: var(--color-bg-dark); box-shadow: 0 0 8px rgba(var(--color-primary-rgb), 0.4); }
        #request-permission-btn { display: none; margin-top: var(--space-xs); }
        #todo-list { list-style: none; padding: 0; margin: 0; max-height: 160px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: var(--color-primary) rgba(var(--color-primary-rgb), 0.1); }
        #todo-list::-webkit-scrollbar { width: 5px; }
        #todo-list::-webkit-scrollbar-track { background: rgba(var(--color-primary-rgb), 0.08); border-radius: 3px;}
        #todo-list::-webkit-scrollbar-thumb { background-color: var(--color-primary); border-radius: 3px; border: 1px solid rgba(var(--color-primary-rgb), 0.2);}
        #todo-list li { background-color: rgba(255, 255, 255, 0.02); border-left: 3px solid var(--color-primary); padding: var(--space-xs) var(--space-sm); margin-bottom: var(--space-xs); border-radius: var(--border-radius-sm); display: flex; justify-content: space-between; align-items: center; gap: var(--space-sm); transition: background-color var(--transition-speed-fast), opacity 0.3s ease, transform 0.3s ease, border-left-color var(--transition-speed-fast); }
        #todo-list li.completed { border-left-color: var(--color-text-secondary); opacity: 0.5; }
        #todo-list li.completed .todo-text { text-decoration: line-through; color: var(--color-text-secondary); }
        #todo-list .todo-content { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; word-break: break-word; }
        #todo-list .todo-text { color: var(--color-text-primary); font-size: 0.9rem; }
        #todo-list .todo-time-info { font-size: 0.7rem; color: var(--color-text-secondary); margin-top: 2px; display: flex; align-items: center; gap: 4px; flex-wrap: wrap; }
        #todo-list .todo-time-info ion-icon { font-size: 0.85em; }
        #todo-list .todo-time-info ion-icon[name="alarm-outline"] { color: var(--color-accent); }
        #todo-list .todo-time-info ion-icon[name="checkmark-done-outline"] { color: var(--color-primary); }
        #todo-list .todo-actions { display: flex; gap: var(--space-xxs); flex-shrink: 0; }
        #todo-list .todo-actions button { background: none; border: none; color: var(--color-text-secondary); font-size: 1.2rem; cursor: pointer; padding: 4px; border-radius: 50%; transition: color var(--transition-speed-fast), background-color var(--transition-speed-fast); display: flex; align-items: center; justify-content: center; }
        #todo-list .todo-actions button.delete-btn:hover { color: #ff4d4d; background-color: rgba(255, 77, 77, 0.1); }
        #todo-list .todo-actions button.complete-btn:hover { color: #4caf50; background-color: rgba(76, 175, 80, 0.1); }
        #todo-list li.completed .todo-actions button.complete-btn { color: #4caf50; }
        #audio-player { background-color: rgba(var(--color-primary-rgb), 0.05); border: 1px solid rgba(var(--color-primary-rgb), 0.2); border-radius: var(--border-radius-md); padding: var(--space-sm); opacity: 0; transform: translateY(10px); box-shadow: inset 0 1px 5px rgba(var(--color-primary-rgb), 0.1); display: flex; flex-direction: column; gap: var(--space-sm); position: relative; }
        #audio-player .track-info { width: 100%; text-align: left; overflow: hidden; display: flex; flex-direction: column; gap: var(--space-xs); }
        #audio-player #track-title { display: block; font-size: 0.95rem; color: var(--color-text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-family: var(--font-secondary); letter-spacing: 0.5px; padding: 0 var(--space-xs); min-height: 1.2em; line-height: 1.3; }
        #audio-player #track-title.is-youtube::before { content: ''; display: inline-block; width: 14px; height: 10px; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 11.2" fill="%23FF0000"><path d="M15.7.9A2 2 0 0014.1 0H1.9A2 2 0 00.3.9 22.6 22.6 0 000 5.6a22.6 22.6 0 00.3 4.7 2 2 0 001.6.9h12.2a2 2 0 001.6-.9 22.6 22.6 0 00.3-4.7 22.6 22.6 0 00-.3-4.7zM6.4 8V3.2l4.6 2.4-4.6 2.4z"/></svg>'); background-repeat: no-repeat; background-size: contain; margin-right: 5px; vertical-align: baseline; }
        #audio-player .progress-container { width: 100%; height: 8px; background-color: rgba(0, 0, 0, 0.3); border-radius: var(--border-radius-sm); cursor: pointer; overflow: hidden; position: relative; border: 1px solid rgba(var(--color-primary-rgb), 0.1); }
        #audio-player #progress-bar { width: 0%; height: 100%; background-color: var(--color-primary); border-radius: var(--border-radius-sm); transition: width 0.1s linear; box-shadow: 0 0 8px 1px var(--color-primary); }
        #audio-player .controls { width: 100%; display: flex; justify-content: center; align-items: center; gap: var(--space-md); padding: 0 var(--space-xs); }
        #audio-player .controls .main-controls { display: flex; align-items: center; gap: var(--space-md); }
        #audio-player .controls button { background: none; border: none; color: var(--color-text-secondary); font-size: 1.6rem; cursor: pointer; padding: var(--space-xs); display: flex; align-items: center; justify-content: center; transition: color var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease, background-color var(--transition-speed-fast) ease; line-height: 1; border-radius: var(--border-radius-circle); }
        #audio-player .controls button:hover, #audio-player .controls button:focus { color: var(--color-secondary); transform: scale(1.1); outline: none; background-color: rgba(var(--color-primary-rgb), 0.1); }
        #audio-player .controls button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; background-color: transparent; }
        #audio-player .controls button ion-icon { display: block; }
        #audio-player button#play-pause-btn { font-size: 2.4rem; color: var(--color-secondary); }
        #audio-player button#play-pause-btn:hover, #audio-player button#play-pause-btn:focus { color: var(--color-primary); background-color: rgba(var(--color-primary-rgb), 0.15); }
        #youtube-player-container { position: absolute; top: -9999px; left: -9999px; width: 1px; height: 1px; opacity: 0; pointer-events: none; overflow: hidden; }
        #anime-search-section { border-top: 1px solid rgba(var(--color-primary-rgb), 0.15); padding-top: var(--space-sm); margin-top: var(--space-sm); opacity: 0; transform: translateY(20px); display: flex; flex-direction: column; gap: var(--space-sm); }
        #search-wrapper { display: flex; gap: var(--space-xs); position: relative; }
        #anime-search-input { flex-grow: 1; padding: var(--space-xs) var(--space-sm); padding-right: 40px; background-color: rgba(var(--color-primary-rgb), 0.05); border: 1px solid rgba(var(--color-primary-rgb), 0.25); border-radius: var(--border-radius-sm); color: var(--color-text-primary); font-family: var(--font-primary); font-size: 0.9rem; transition: border-color var(--transition-speed-fast), box-shadow var(--transition-speed-fast); }
        #anime-search-input:focus { outline: none; border-color: var(--color-primary); box-shadow: 0 0 8px rgba(var(--color-primary-rgb), 0.3); }
        #anime-search-input::placeholder { color: var(--color-text-secondary); opacity: 0.7; }
        #anime-search-input:disabled { cursor: not-allowed; opacity: 0.6; }
        #anime-search-input::-webkit-search-cancel-button, #anime-search-input::-webkit-search-decoration { -webkit-appearance: none; appearance: none; }
        #search-button { position: absolute; right: 1px; top: 1px; bottom: 1px; background: none; border: none; color: var(--color-text-secondary); font-size: 1.4rem; cursor: pointer; padding: 0 var(--space-xs); border-radius: 0 var(--border-radius-sm) var(--border-radius-sm) 0; transition: color var(--transition-speed-fast); display: flex; align-items: center; justify-content: center; }
        #search-button:disabled { cursor: not-allowed; opacity: 0.5; color: var(--color-text-secondary) !important; }
        #search-button:not(:disabled):hover { color: var(--color-primary); }
        #anime-results-container, #anime-episode-list-container { background-color: rgba(255, 255, 255, 0.02); border: 1px solid rgba(var(--color-primary-rgb), 0.1); border-radius: var(--border-radius-md); padding: var(--space-sm); min-height: 60px; max-height: 250px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: var(--color-primary) rgba(var(--color-primary-rgb), 0.1); transition: all 0.3s ease; }
        #anime-results-container::-webkit-scrollbar, #anime-episode-list-container::-webkit-scrollbar { width: 5px; }
        #anime-results-container::-webkit-scrollbar-track, #anime-episode-list-container::-webkit-scrollbar-track { background: rgba(var(--color-primary-rgb), 0.08); border-radius: 3px;}
        #anime-results-container::-webkit-scrollbar-thumb, #anime-episode-list-container::-webkit-scrollbar-thumb { background-color: var(--color-primary); border-radius: 3px; border: 1px solid rgba(var(--color-primary-rgb), 0.2);}
        #anime-episode-list-container { display: none; flex-direction: column; gap: var(--space-xs); }
        #episode-list-heading { margin-bottom: var(--space-xs); padding-bottom: var(--space-xs); border-bottom: 1px dashed rgba(var(--color-primary-rgb), 0.2); text-align: left; }
        #anime-episode-list { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: var(--space-xs); }
        .search-result-item, .episode-item { background-color: rgba(var(--color-primary-rgb), 0.08); border-left: 3px solid var(--color-accent); padding: var(--space-xs) var(--space-sm); border-radius: var(--border-radius-sm); cursor: pointer; transition: all var(--transition-speed-fast) ease; font-size: 0.9rem; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; text-align: left; }
        .episode-item[style*="cursor: not-allowed"] { border-left-color: var(--color-text-secondary); }
        .search-result-item:hover, .episode-item:not([style*="cursor: not-allowed"]):hover, .search-result-item:focus, .episode-item:not([style*="cursor: not-allowed"]):focus { background-color: rgba(var(--color-primary-rgb), 0.2); border-left-color: var(--color-primary); transform: translateX(4px); outline: none; box-shadow: 0 0 5px rgba(var(--color-primary-rgb), 0.3); }
        .placeholder-text { color: var(--color-text-secondary); text-align: center; padding: var(--space-sm); font-style: italic; font-size: 0.9rem; }
        .placeholder-text.error { color: var(--color-accent); font-style: normal; }
        #back-to-search-btn { padding: var(--space-xs) var(--space-sm); background-color: rgba(var(--color-primary-rgb), 0.1); border: 1px solid rgba(var(--color-primary-rgb), 0.5); color: var(--color-primary); font-family: var(--font-secondary); font-weight: 500; font-size: 0.85rem; border-radius: var(--border-radius-sm); cursor: pointer; transition: all var(--transition-speed-fast) ease; display: inline-flex; align-items: center; justify-content: center; gap: var(--space-xxs); align-self: flex-start; margin-top: var(--space-sm); }
        #back-to-search-btn ion-icon { font-size: 1.1em; }
        #back-to-search-btn:hover, #back-to-search-btn:focus { background-color: var(--color-primary); color: var(--color-bg-dark); box-shadow: 0 0 8px rgba(var(--color-primary-rgb), 0.4); outline: none; }
        #anime-player-container { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9); width: 90%; max-width: 800px; background-color: rgba(10, 10, 10, 0.85); backdrop-filter: blur(15px) saturate(190%); -webkit-backdrop-filter: blur(15px) saturate(190%); border: 1px solid rgba(var(--color-primary-rgb), 0.3); border-radius: var(--border-radius-lg); padding: var(--space-md); z-index: 1000; box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7); display: flex; flex-direction: column; gap: var(--space-sm); opacity: 0; transition: opacity 0.3s ease, transform 0.3s ease; will-change: opacity, transform; visibility: hidden; }
        #anime-player-container.visible { opacity: 1; transform: translate(-50%, -50%) scale(1); visibility: visible; }
        #player-anime-title { font-family: var(--font-secondary); color: var(--color-primary); text-align: center; font-size: 1rem; margin: 0; padding-bottom: var(--space-xs); border-bottom: 1px solid rgba(var(--color-primary-rgb), 0.2); overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
        .iframe-wrapper { position: relative; width: 100%; padding-bottom: 56.25%; height: 0; background-color: #000; border-radius: var(--border-radius-sm); overflow: hidden; border: 1px solid rgba(var(--color-primary-rgb), 0.1); }
        #anime-iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }
        #close-player-btn { position: absolute; top: var(--space-xs); right: var(--space-xs); background: none; border: none; color: var(--color-text-secondary); font-size: 1.8rem; cursor: pointer; padding: 2px; line-height: 1; transition: color var(--transition-speed-fast), transform var(--transition-speed-fast); border-radius: 50%; z-index: 10; }
        #close-player-btn:hover, #close-player-btn:focus { color: var(--color-primary); transform: rotate(90deg); outline: none; }
        body.player-open::after { content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(3px); -webkit-backdrop-filter: blur(3px); z-index: 999; opacity: 0; transition: opacity 0.3s ease; pointer-events: all; visibility: hidden; }
        body.player-open::after { opacity: 1; visibility: visible; }
        #links { border-top: 1px solid rgba(var(--color-primary-rgb), 0.15); padding-top: var(--space-sm); margin-top: var(--space-sm); }
        #links ul { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: var(--space-sm); }
        #links li { opacity: 0; transform: translateX(-20px); }
        #links a { display: block; padding: var(--space-sm) var(--space-md); text-decoration: none; color: var(--color-text-primary); background-color: rgba(var(--color-primary-rgb), 0.1); border: 1px solid rgba(var(--color-primary-rgb), 0.5); border-radius: var(--border-radius-sm); font-weight: 500; transition: all var(--transition-speed-fast) ease-out; position: relative; overflow: hidden; z-index: 1; will-change: transform, background-color, box-shadow; text-align: center; }
        #links a::before { content: ""; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(var(--color-primary-rgb), 0.4), transparent); transition: left var(--transition-speed-normal) ease-out; z-index: -1; }
        #links a:hover, #links a:focus { background-color: rgba(var(--color-primary-rgb), 0.25); border-color: var(--color-primary); color: #fff; transform: scale(1.03); box-shadow: 0 0 15px rgba(var(--color-primary-rgb), 0.4); outline: none; }
        #links a:hover::before, #links a:focus::before { left: 100%; }
        #links a:active { transform: scale(0.98); background-color: rgba(var(--color-primary-rgb), 0.3); }
        #social-links { display: flex; justify-content: center; gap: var(--space-md); padding-top: var(--space-sm); border-top: 1px solid rgba(255, 255, 255, 0.1); opacity: 0; transform: translateY(20px); }
        #social-links a { display: inline-flex; align-items: center; justify-content: center; color: var(--color-text-secondary); font-size: 1.6rem; width: 40px; height: 40px; border-radius: var(--border-radius-circle); text-decoration: none; transition: all var(--transition-speed-fast) ease; will-change: transform, color, background-color; }
        #social-links a:hover, #social-links a:focus { color: var(--color-primary); transform: translateY(-3px) scale(1.1); outline: none; background-color: rgba(var(--color-primary-rgb), 0.1); }
        #social-links ion-icon { display: block; }
        footer { margin-top: var(--space-xs); font-size: 0.8rem; color: var(--color-text-secondary); opacity: 0; transform: translateY(20px); text-align: center; }
        footer a { color: var(--color-accent); text-decoration: none; font-weight: 500; transition: color var(--transition-speed-fast) ease, text-shadow var(--transition-speed-fast) ease; }
        footer a:hover, footer a:focus { color: var(--color-secondary); text-shadow: 0 0 5px var(--color-secondary); outline: none; }
        @media (min-width: 500px) { #todo-form { flex-direction: row; align-items: center; } #todo-form input[type="text"] { max-width: none; } #todo-form input[type="time"] { flex-basis: 100px; } #add-todo-btn { align-self: center; } }
        @media (max-width: 768px) { :root { --space-lg: 1.8rem; --space-md: 1.1rem; --space-sm: 0.75rem; } #container { padding: var(--space-md); margin: var(--space-sm); gap: var(--space-sm); } #profile-image-wrapper { width: 90px; height: 90px; } #clock {font-size: 0.8rem;} #audio-player{ padding: var(--space-xs); } #audio-player #track-title { font-size: 0.9rem; } #audio-player .controls {gap: var(--space-sm);} #audio-player .controls button {font-size: 1.5rem;} #audio-player button#play-pause-btn {font-size: 2.2rem;} #social-links { gap: var(--space-sm); } #social-links a { font-size: 1.5rem; width: 38px; height: 38px; } #anime-results-container, #anime-episode-list-container { max-height: 200px;} }
        @media (max-width: 420px) { :root { --space-md: 1rem; --space-sm: 0.65rem; } #profile-image-wrapper { width: 80px; height: 80px; } #clock {letter-spacing: 1px;} #audio-player #track-title {font-size: 0.85rem;} #audio-player .controls {gap: var(--space-xs);} #audio-player .controls button {font-size: 1.4rem; padding: calc(var(--space-xs) / 2);} #audio-player button#play-pause-btn {font-size: 2rem;} #social-links { gap: var(--space-xs); } #social-links a { font-size: 1.4rem; width: 34px; height: 34px; } #links a { padding: var(--space-sm); } #todo-list li { flex-direction: column; align-items: flex-start; } #todo-list .todo-actions { margin-top: var(--space-xs); align-self: flex-end; } #todo-form .todo-input-group { flex-direction: column; } #todo-form input[type="time"] { flex-basis: auto; width: 100%; } #add-todo-btn { width: 100%; margin-top: var(--space-xs); } #anime-results-container, #anime-episode-list-container { max-height: 180px;} .search-result-item, .episode-item { font-size: 0.85rem;} }
        .visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }
    </style>
</head>
<body>

    <div id="container">
        <div id="profile">
             <div id="profile-image-wrapper">
                 <img id="avatar" src="https://niyakipham.github.io/assets/kaguya.jpeg" alt="·∫¢nh ƒë·∫°i di·ªán anime c·ªßa Niyaki Ph·∫°m"/>
            </div>
             <p id="username" data-text="@niyakipham">@niyakipham</p>
             <div id="clock">00:00:00</div>
         </div>

        <!-- /// TO-DO LIST SECTION /// -->
         <section id="todo-section" aria-labelledby="todo-heading">
             <h2 id="todo-heading" class="sci-fi-heading">TO DO LIST</h2>
             <form id="todo-form" aria-label="Th√™m nhi·ªám v·ª• m·ªõi">
                 <div class="todo-input-group">
                    <input type="text" id="todo-input" placeholder="Nhi·ªám v·ª• m·ªõi..." required aria-label="N·ªôi dung nhi·ªám v·ª•">
                     <input type="time" id="todo-time" aria-label="Th·ªùi gian nh·∫Øc nh·ªü" title="Ch·ªçn gi·ªù nh·∫Øc nh·ªü (trong ng√†y)">
                 </div>
                <button type="submit" id="add-todo-btn" aria-label="Th√™m nhi·ªám v·ª•">
                    <ion-icon name="add-circle-outline"></ion-icon> ADD
                </button>
            </form>
            <ul id="todo-list" aria-live="polite"><!-- Todo items appear here --></ul>
            <button id="request-permission-btn" style="display: none;" aria-label="Y√™u c·∫ßu quy·ªÅn hi·ªÉn th·ªã th√¥ng b√°o">
                <ion-icon name="notifications-outline"></ion-icon> Cho ph√©p th√¥ng b√°o
             </button>
         </section>
         <!-- /// END TO-DO LIST /// -->

        <!-- /// AUDIO PLAYER /// -->
        <div id="audio-player">
             <div class="track-info">
                  <span id="track-title" title="ƒêang t·∫£i nh·∫°c...">ƒêang t·∫£i nh·∫°c...</span>
                  <div class="progress-container"><div id="progress-bar"></div></div>
            </div>
              <div class="controls">
                  <div class="main-controls">
                      <button id="prev-btn" aria-label="B√†i tr∆∞·ªõc" disabled><ion-icon name="play-skip-back-outline"></ion-icon></button>
                      <button id="play-pause-btn" aria-label="Ph√°t nh·∫°c" disabled><ion-icon name="play-outline"></ion-icon></button> <!-- Start disabled, enable on init if playlist exists -->
                      <button id="next-btn" aria-label="B√†i ti·∫øp theo" disabled><ion-icon name="play-skip-forward-outline"></ion-icon></button>
                 </div>
              </div>
             <!-- Container ·∫©n cho YouTube Player -->
             <div id="youtube-player-container"></div>
         </div>
         <!-- /// END AUDIO PLAYER /// -->

         <!-- === ANIME SEARCH SECTION === -->
         <section id="anime-search-section" aria-labelledby="anime-search-heading">
            <h2 id="anime-search-heading" class="sci-fi-heading">KH√ÅM PH√Å ANIME</h2>
            <div id="search-wrapper">
                 <input type="search" id="anime-search-input" placeholder="ƒêang t·∫£i data..." aria-label="Nh·∫≠p t√™n anime c·∫ßn t√¨m" disabled>
                 <button id="search-button" aria-label="T√¨m ki·∫øm" disabled><ion-icon name="search-outline"></ion-icon></button>
             </div>
            <div id="anime-results-container" aria-live="polite">
                  <p class="placeholder-text">ƒêang t·∫£i d·ªØ li·ªáu anime...</p>
             </div>
             <div id="anime-episode-list-container">
                  <h3 id="episode-list-heading" class="sci-fi-heading" style="display: none;">Anime Title</h3>
                  <ul id="anime-episode-list" aria-live="polite"></ul>
                  <button id="back-to-search-btn" style="display: none;"><ion-icon name="arrow-back-outline"></ion-icon> Quay l·∫°i</button>
             </div>
         </section>
         <!-- === END ANIME SEARCH SECTION === -->

         <!-- /// LINKS LIST /// -->
         <nav id="links" aria-label="Li√™n k·∫øt ch√≠nh">
              <span id="main-content" class="visually-hidden">N·ªôi dung ch√≠nh</span>
            <ul>
                 <li><a href="https://facebook.com/niyakipham" target="_blank" rel="noopener noreferrer">Facebook</a></li>
                <li><a href="https://zalo.me/0901574726" target="_blank" rel="noopener noreferrer">Zalo</a></li>
                 <li><a href="https://github.com/niyakipham" target="_blank" rel="noopener noreferrer">Github</a></li>
                 <li><a href="https://discordapp.com/users/niyakipham.off" target="_blank" rel="noopener noreferrer">Discord</a></li>
             </ul>
         </nav>
         <!-- /// END LINKS LIST /// -->

        <!-- /// SOCIAL LINKS /// -->
        <div id="social-links" aria-label="Li√™n k·∫øt m·∫°ng x√£ h·ªôi kh√°c">
             <a href="https://github.com/niyakipham" target="_blank" rel="noopener noreferrer" aria-label="Niyaki Ph·∫°m tr√™n Github" title="Github"><ion-icon name="logo-github"></ion-icon></a>
            <a href="https://instagram.com/niyakipham" target="_blank" rel="noopener noreferrer" aria-label="Niyaki Ph·∫°m tr√™n Instagram" title="Instagram"><ion-icon name="logo-instagram"></ion-icon></a>
            <a href="https://youtube.com/@Nishimahayashii" target="_blank" rel="noopener noreferrer" aria-label="Niyaki Ph·∫°m tr√™n Youtube" title="YouTube"><ion-icon name="logo-youtube"></ion-icon></a>
             <a href="https://www.linkedin.com/in/niyakipham/" target="_blank" rel="noopener noreferrer" aria-label="Niyaki Ph·∫°m tr√™n LinkedIn" title="LinkedIn"><ion-icon name="logo-linkedin"></ion-icon></a>
         </div>

        <!-- /// FOOTER /// -->
         <footer>
              Website ƒë∆∞·ª£c t·∫°o v·ªõi ‚ù§Ô∏è b·ªüi <a href="https://github.com/niyakipham" target="_blank" rel="noopener noreferrer">Niyaki Pham (Ph·∫°m VƒÉn Ho√†ng)</a>
         </footer>

     </div> <!-- End #container -->

     <!-- === IFRAME PLAYER CONTAINER (Anime Viewer) === -->
     <div id="anime-player-container">
         <button id="close-player-btn" aria-label="ƒê√≥ng tr√¨nh ph√°t"><ion-icon name="close-circle-outline"></ion-icon></button>
         <h4 id="player-anime-title">Anime Title - Episode Name</h4>
         <div class="iframe-wrapper">
             <iframe id="anime-iframe" src="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen title="Anime Player"></iframe>
         </div>
     </div>
     <!-- === END IFRAME PLAYER CONTAINER === -->

    <script>
        //********* JAVASCRIPT - VERSION 15.0 (Autoplay Next Fix & Error Skip) *********//
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONFIGURATION ---
            const introStaggerDelay = 70;
            const glitchEffectOnLoad = true;
            const glitchDuration = 1500;
            const ANIME_DATA_URL = 'https://raw.githubusercontent.com/niyakipham/data/refs/heads/main/anisub/anidata.csv';
             const AUTO_SKIP_DELAY = 1500; // Th·ªùi gian ch·ªù (ms) tr∆∞·ªõc khi t·ª± ƒë·ªông b·ªè qua b√†i l·ªói

            // --- *** PLAYLIST DATA *** ---
            const playlist = [
                { type: 'youtube', videoId: '5GUaMOpfmr8', title: 'Tada Koe Hitotsu (From BORUTO: NARUTO NEXT GENERATIONS)', artist: '„É≠„ÇØ„Éá„Éä„Ç∑'},
                { type: 'youtube', videoId: 'hE2bHwqqYcc', title: 'Niji (From STAND BY ME Doraemon 2)', artist: 'Masaki Suda'},
                { type: 'youtube', videoId: 'AZLfAzVy_PM', title: 'Best Friend (From Mushoku Tensei)', artist: 'Yuiko Ohara'},
                 // Th√™m URL MP3 ƒë·ªÉ test autoplay
                // { type: 'url', url: 'LINK_MP3_HOP_LE_CUA_BAN.mp3', title: 'B√†i MP3 test', artist: 'Niyaki Pham'}, // <-- Nh·ªõ thay link
                 { type: 'youtube', videoId: 'INVALID_ID_TEST', title: 'Test B√†i L·ªói ID', artist: 'Niyaki Pham'}, // <-- B√†i c·ªë t√¨nh l·ªói
                { type: 'youtube', videoId: 'MW79zgnSF40', title: 'Like I Do', artist: 'J.Tajor'},
                { type: 'youtube', videoId: '12gmxhEFeBo', title: 'Payphone', artist: 'Maroon 5 ft. Wiz Khalifa'},
                { type: 'youtube', videoId: 'QwiuihFPPok', title: 'Tonight', artist: 'NEFFEX'},
                { type: 'youtube', videoId: 'HsM9VucuCtw', title: 'Shadow Of The Sun', artist: 'Max Elto'},
                { type: 'youtube', videoId: 'mv23MnaNvGM', title: 'Love Is Gone (Acoustic)', artist: 'SLANDER ft. Dylan Matthew'},
                { type: 'youtube', videoId: 'p7CuxzGWY40', title: "Don't Leave Me", artist: 'Tom Frane & Polina Grace'},
                { type: 'youtube', videoId: 'JzFZVmsZYOA', title: 'Lofi Chill 2024 Mix', artist: 'Various Lofi Artists'},
            ];

            // --- GET DOM ELEMENTS ---
            const container = document.getElementById('container');
            const clockElement = document.getElementById('clock');
            const usernameElement = document.getElementById('username');
            const avatar = document.getElementById('avatar');
            const avatarSrc = avatar?.src;
            const todoSection = document.getElementById('todo-section');
            const todoForm = document.getElementById('todo-form');
            const todoInput = document.getElementById('todo-input');
            const todoTimeInput = document.getElementById('todo-time');
            const todoListElement = document.getElementById('todo-list');
            const requestPermissionBtn = document.getElementById('request-permission-btn');
            const audioPlayer = document.getElementById('audio-player');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const playIcon = playPauseBtn?.querySelector('ion-icon');
            const progressBar = document.getElementById('progress-bar');
            const progressContainer = audioPlayer?.querySelector('.progress-container');
            const trackTitleElement = document.getElementById('track-title');
            const mainLinks = document.querySelectorAll('#links a');
            const socialLinksContainer = document.getElementById('social-links');
            const footerElement = document.querySelector('footer');
            const animeSearchSection = document.getElementById('anime-search-section');
            const searchInput = document.getElementById('anime-search-input');
            const searchButton = document.getElementById('search-button');
            const resultsContainer = document.getElementById('anime-results-container');
            const episodeListContainer = document.getElementById('anime-episode-list-container');
            const episodeListHeading = document.getElementById('episode-list-heading');
            const episodeListUl = document.getElementById('anime-episode-list');
            const playerContainer = document.getElementById('anime-player-container');
            const playerIframe = document.getElementById('anime-iframe');
            const playerTitle = document.getElementById('player-anime-title');
            const closePlayerBtn = document.getElementById('close-player-btn');
            const backToSearchBtn = document.getElementById('back-to-search-btn');
            const youtubePlayerContainer = document.getElementById('youtube-player-container');

            // --- STATE VARIABLES ---
            let audio = null;
            let currentTrackIndex = -1;
            let isPlaying = false;
            let userHasInteracted = false;
             let playOnReady = false; // <<-- ƒê·ªïi t√™n t·ª´ playAfterLoad cho r√µ nghƒ©a h∆°n
            let tasks = [];
            let notificationPermission = 'Notification' in window ? Notification.permission : 'unsupported';
            let clockInterval = null;
            let allEpisodeRecords = [];
            let currentAnimeTitle = '';
            let youtubePlayer = null;
            let youtubeApiReady = false;
            let youtubePlayerReady = false;
            let youtubeProgressInterval = null;
            let currentPlayerType = 'none';
            const hasMediaSession = ('mediaSession' in navigator);
             let skipTrackTimeout = null; // <<<--- [M·ªöI] Timeout ƒë·ªÉ t·ª± ƒë·ªông b·ªè qua b√†i l·ªói

            // ============================
            // === HELPER FUNCTIONS (Kh√¥ng ƒë·ªïi) ===
            // ============================
            function generateId() { return Date.now().toString(36) + Math.random().toString(36).substring(2, 7); }
            function formatTimeForDisplay(date) { if (!date || !(date instanceof Date) || isNaN(date)) return null; try { const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; } catch (e) { console.error("L·ªói ƒë·ªãnh d·∫°ng gi·ªù:", e); return null; } }
            function setPrimaryColorRGB() { if(typeof window==='undefined'||!document?.documentElement)return;try{const s=window.getComputedStyle(document.documentElement);let c=s.getPropertyValue('--color-primary').trim();let r=225,g=29,b=72;if(c.startsWith('#')){const h=c.substring(1);if(h.length===3){r=parseInt(h[0]+h[0],16);g=parseInt(h[1]+h[1],16);b=parseInt(h[2]+h[2],16);}else if(h.length===6){r=parseInt(h.substring(0,2),16);g=parseInt(h.substring(2,4),16);b=parseInt(h.substring(4,6),16);}}else if(c.startsWith('rgb')){const p=c.match(/(\d+)/g);if(p&&p.length>=3){r=parseInt(p[0],10);g=parseInt(p[1],10);b=parseInt(p[2],10);}}if(isNaN(r)||isNaN(g)||isNaN(b)){[r,g,b]=[225,29,72];console.warn("Cannot parse primary color, using default.");}document.documentElement.style.setProperty('--color-primary-rgb',`${r}, ${g}, ${b}`);}catch(e){console.error("Error setting primary RGB:",e);document.documentElement.style.setProperty('--color-primary-rgb',`225, 29, 72`);}}
            function splitCsvLine(line) { const result = []; let current = ''; let inQuotes = false; for (let i = 0; i < line.length; i++) { const char = line[i]; if (char === '"') { if (inQuotes && line[i + 1] === '"') { current += '"'; i++; } else { inQuotes = !inQuotes; } } else if (char === ',' && !inQuotes) { result.push(current); current = ''; } else { current += char; } } result.push(current); return result; }
            function parseCSV_NameEpisodeLink(csvText) { if (!csvText) return []; const lines = csvText.trim().split('\n'); if (lines.length <= 1) return []; const header = lines[0].split(',').map(h => h.trim().toLowerCase()); const data = []; const nameIndex = header.indexOf('name'); const episodeNameIndex = header.indexOf('episodes'); const linkIndex = header.indexOf('link'); if (nameIndex===-1 || episodeNameIndex===-1 || linkIndex===-1) { console.error("‚ùå Critical Error: CSV must contain 'name', 'episodes', 'link'. Header:", header.join(', ')); if (resultsContainer) resultsContainer.innerHTML = '<p class="placeholder-text error">L·ªói c·∫•u tr√∫c file d·ªØ li·ªáu.</p>'; return []; } for (let i = 1; i < lines.length; i++) { const line = lines[i].trim(); if (!line) continue; try { const parts = splitCsvLine(line); if (parts.length <= Math.max(nameIndex, episodeNameIndex, linkIndex)) { console.warn(`‚ö†Ô∏è Skipping line ${i+1}: Not enough columns. "${line.substring(0,50)}..."`); continue; } const animeName = parts[nameIndex]?.trim(); const episodeName = parts[episodeNameIndex]?.trim(); const link = parts[linkIndex]?.trim(); if (!animeName || !episodeName) { console.warn(`‚ö†Ô∏è Skipping line ${i+1}: Missing name/episode. Name: '${animeName}', Ep: '${episodeName}'`); continue; } data.push({ animeName: animeName, episodeName: episodeName, link: link || '#' }); } catch (e) { console.error(`‚ùå Error CSV line ${i+1}: "${line.substring(0, 100)}...". Error: ${e.message}`); } } console.log(`‚ÑπÔ∏è Parsed ${data.length} episode records.`); return data; }
            function formatTimeForDisplayYT(seconds) { if (isNaN(seconds) || seconds < 0) return '0:00'; const minutes = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${minutes}:${secs < 10 ? '0' : ''}${secs}`; }

            // ============================
            // === MEDIA SESSION API FUNCTIONS (Kh√¥ng ƒë·ªïi) ===
            // ============================
            function updateMediaSessionMetadata() {
                 if (!hasMediaSession || currentTrackIndex < 0 || currentTrackIndex >= playlist.length) return;
                 const track = playlist[currentTrackIndex];
                 const metadata = {
                     title: track.title || 'Unknown Title', artist: track.artist || 'Niyaki Pham', album: 'Niyaki Pham\'s Playlist',
                     artwork: [{ src: avatarSrc || 'https://via.placeholder.com/96', sizes: '96x96', type: 'image/jpeg' }, { src: avatarSrc || 'https://via.placeholder.com/128', sizes: '128x128', type: 'image/jpeg' }]
                 };
                 try { navigator.mediaSession.metadata = new MediaMetadata(metadata); console.log('üéß Media Session metadata updated:', metadata.title); } catch (error) { console.error('Failed to set Media Session metadata:', error); }
             }
             function setupMediaSessionActions() {
                 if (!hasMediaSession) return;
                try { navigator.mediaSession.setActionHandler('play', playAudio); } catch (e) { console.warn("Could not set 'play' action:", e); }
                try { navigator.mediaSession.setActionHandler('pause', pauseAudio); } catch (e) { console.warn("Could not set 'pause' action:", e); }
                 if (playlist.length > 1) {
                    try { navigator.mediaSession.setActionHandler('previoustrack', playPrevTrack); } catch (e) { console.warn("Could not set 'previoustrack' action:", e); }
                    try { navigator.mediaSession.setActionHandler('nexttrack', () => playNextTrack(false)); } catch (e) { console.warn("Could not set 'nexttrack' action:", e); }
                 } else {
                    try { navigator.mediaSession.setActionHandler('previoustrack', null); } catch (e) {}
                    try { navigator.mediaSession.setActionHandler('nexttrack', null); } catch (e) {}
                 }
             }
            function updateMediaSessionPlaybackState() {
                 if (!hasMediaSession) return;
                 navigator.mediaSession.playbackState = isPlaying ? 'playing' : 'paused';
                 console.log(`üéß Media Session state updated: ${navigator.mediaSession.playbackState}`);
             }
             function updateAudioPositionState() {
                 if (!hasMediaSession || currentPlayerType !== 'url' || !audio || !audio.duration || isNaN(audio.duration)) return;
                 try { navigator.mediaSession.setPositionState({ duration: audio.duration, playbackRate: audio.playbackRate || 1, position: audio.currentTime }); } catch(e) { /* ignore minor errors */ }
             }

            // ============================
            // === YOUTUBE API FUNCTIONS ===
            // ============================
             function loadYouTubeAPI() { /* gi·ªØ nguy√™n */ }
             window.onYouTubeIframeAPIReady = function() { /* gi·ªØ nguy√™n */ }

            function onPlayerReady(event) {
                 console.log("‚úÖ YT Player Instance Ready (onReady). State:", event.target.getPlayerState());
                clearTimeout(skipTrackTimeout); // <<<--- [M·ªöI] H·ªßy timeout b·ªè qua l·ªói n·∫øu player s·∫µn s√†ng
                youtubePlayerReady = true;
                enableMainControls(); // << Enable controls first
                updatePrevNextButtonStates(); // Then update prev/next based on enabled main controls
                setYouTubeVolume(audio?.volume ?? 0.8);
                 updateMediaSessionMetadata();
                 setupMediaSessionActions(); // Re-setup actions might be needed if player was recreated
                // Update state immediately (important for CUED state after loading)
                 updateMediaSessionPlaybackState();

                // Handle playOnReady flag AFTER enabling controls and setting up state
                if (playOnReady) {
                    console.log("onPlayerReady: playOnReady=true -> Calling playAudio()");
                     // Reset flag *before* calling playAudio to prevent potential loops
                     playOnReady = false;
                    playAudio();
                 } else {
                     // Ensure state is updated even if not auto-playing
                     updateYouTubeProgressAndDuration();
                     updateMediaSessionPlaybackState(); // Might be redundant but safe
                 }
            }

            function onPlayerStateChange(event) {
                 const state = event.data;
                 const stateName = Object.keys(YT.PlayerState).find(key => YT.PlayerState[key] === state) || 'UNKNOWN';
                 console.log(`YT State Change: ${stateName} (${state})`);
                 clearTimeout(skipTrackTimeout); // <<<--- [M·ªöI] H·ªßy timeout l·ªói n·∫øu c√≥ s·ª± thay ƒë·ªïi tr·∫°ng th√°i

                 if (state === YT.PlayerState.PLAYING) {
                    if (!isPlaying) { isPlaying = true; updatePlayPauseButton(true); container?.classList.add('is-playing'); }
                     if (!youtubePlayerReady) youtubePlayerReady = true;
                     updateMediaSessionPlaybackState();
                     if (!youtubeProgressInterval) startYouTubeProgressTracking();
                 } else if (state === YT.PlayerState.PAUSED) {
                    if (isPlaying) { isPlaying = false; updatePlayPauseButton(false); container?.classList.remove('is-playing'); }
                    if (youtubeProgressInterval) { clearInterval(youtubeProgressInterval); youtubeProgressInterval = null; }
                     updateMediaSessionPlaybackState();
                 } else if (state === YT.PlayerState.ENDED) {
                    if (isPlaying) { isPlaying = false; updatePlayPauseButton(false); container?.classList.remove('is-playing'); }
                     if (youtubeProgressInterval) { clearInterval(youtubeProgressInterval); youtubeProgressInterval = null; }
                     if (progressBar) progressBar.style.width = '100%'; // Show finished state
                    updateMediaSessionPlaybackState();
                     console.log("YT Ended, calling playNextTrack(true)");
                     playNextTrack(true); // <<--- Auto-play next
                } else if (state === YT.PlayerState.CUED) {
                     youtubePlayerReady = true; // Mark as ready
                     if (isPlaying) { // Should not be playing if cued, correct state
                        isPlaying = false; updatePlayPauseButton(false); updateMediaSessionPlaybackState();
                     }
                    enableMainControls(); updatePrevNextButtonStates(); // Ensure controls are active
                     updateYouTubeProgressAndDuration(); // Update time display
                    updateMediaSessionMetadata(); // Refresh metadata
                 } else if (state === YT.PlayerState.BUFFERING) {
                     // Optional: Show buffering indicator
                 } else if (state === YT.PlayerState.UNSTARTED) {
                    youtubePlayerReady = true; // API is ready, player just hasn't started (e.g. after loadVideoById)
                 }

                 // Enable controls if player is interactive (playing, paused, cued)
                if ([YT.PlayerState.PLAYING, YT.PlayerState.PAUSED, YT.PlayerState.CUED, YT.PlayerState.UNSTARTED].includes(state)) {
                     enableMainControls(); updatePrevNextButtonStates();
                 }
            }

            function onPlayerError(event) {
                 console.error("YT Player Error Code:", event.data, "for track:", currentTrackIndex);
                clearTimeout(skipTrackTimeout); // <<<--- [M·ªöI] H·ªßy timeout n·∫øu c√≥ l·ªói kh√°c
                let errorMsg = `L·ªói YT Player (${event.data})`;
                 // ... (error messages mapping) ...
                 if (trackTitleElement) { trackTitleElement.textContent = errorMsg; trackTitleElement.classList.remove('is-youtube'); }
                 disableAllControls(); // T·∫°m th·ªùi v√¥ hi·ªáu h√≥a ƒë·ªÉ tr√°nh l·ªói th√™m
                isPlaying = false; youtubePlayerReady = false; // Mark player as not ready
                 // Kh√¥ng reset currentPlayerType ho·∫∑c currentTrackIndex ·ªü ƒë√¢y
                updatePlayPauseButton(false); container?.classList.remove('is-playing');
                if (youtubeProgressInterval) { clearInterval(youtubeProgressInterval); youtubeProgressInterval = null; }
                 updateMediaSessionPlaybackState(); // Update to paused state

                 // *** [M·ªöI] T·ª± ƒë·ªông b·ªè qua b√†i l·ªói ***
                 console.warn(`YT Error ${event.data} on track ${currentTrackIndex}. Attempting to auto-skip in ${AUTO_SKIP_DELAY}ms...`);
                // Ch·ªâ g·ªçi playNext n·∫øu playlist c√≥ nhi·ªÅu h∆°n 1 b√†i
                 if (playlist.length > 1) {
                     skipTrackTimeout = setTimeout(() => {
                         console.log(`Auto-skipping failed YT track ${currentTrackIndex}...`);
                         playNextTrack(true); // true ƒë·ªÉ th·ª≠ autoplay b√†i ti·∫øp theo
                     }, AUTO_SKIP_DELAY);
                 } else {
                    console.warn("Only one track in playlist or error on the only track. Cannot skip.");
                 }
             }
             function startYouTubeProgressTracking() { /* gi·ªØ nguy√™n */ }
             function updateYouTubeProgressAndDuration() { /* gi·ªØ nguy√™n logic Media Session position */ }
             function setYouTubeVolume(volume) { /* gi·ªØ nguy√™n */ }

            // ============================
            // === CORE PLAYER LOGIC ===
            // ============================

             function loadTrack(index, playWhenReady = false) { // << Th√™m tham s·ªë playWhenReady
                 if (!playlist || index < 0 || index >= playlist.length) { console.error("Load track failed: Invalid index."); return; }
                 console.log(`--- Loading Track ${index} (Play when ready: ${playWhenReady}) ---`);
                clearTimeout(skipTrackTimeout); // <<<--- [M·ªöI] H·ªßy m·ªçi timeout skip ƒëang ch·ªù
                playOnReady = playWhenReady; // << L∆∞u l·∫°i √Ω ƒë·ªãnh play

                 // Stop previous playback carefully
                const previousPlayerType = currentPlayerType;
                if (previousPlayerType === 'url' && audio && !audio.paused) audio.pause();
                 else if (previousPlayerType === 'youtube' && youtubePlayer && youtubePlayerReady && typeof youtubePlayer.stopVideo === 'function') youtubePlayer.stopVideo();
                if (youtubeProgressInterval) { clearInterval(youtubeProgressInterval); youtubeProgressInterval = null; }
                if (hasMediaSession && isPlaying) { updateMediaSessionPlaybackState(); /* Set to paused */ }

                 // Reset common state BEFORE loading new track
                 isPlaying = false;
                youtubePlayerReady = false; // Assume YT not ready until 'onReady' or 'onStateChange' confirms
                 currentTrackIndex = index;
                 updatePlayPauseButton(false); // Show play icon initially
                 if (progressBar) progressBar.style.width = '0%';
                 container?.classList.remove('is-playing');
                 disableAllControls(); // V√¥ hi·ªáu h√≥a cho ƒë·∫øn khi s·∫µn s√†ng

                 const track = playlist[currentTrackIndex];
                 currentPlayerType = track.type || 'url'; // Update current player type
                 const displayTitle = track.title || (currentPlayerType === 'youtube' ? `YouTube: ${track.videoId}` : `Track ${index + 1}`);
                 if (trackTitleElement) { /* update title & class */ }

                // Update Media Session metadata & actions early
                 updateMediaSessionMetadata();
                 setupMediaSessionActions();

                if (currentPlayerType === 'youtube') {
                     console.log(`Type: YouTube, ID: ${track.videoId}`);
                     if (!track.videoId) { console.error("Invalid YT videoId!"); if (trackTitleElement) trackTitleElement.textContent="L·ªói ID"; currentPlayerType='none'; skipTrackTimeout = setTimeout(()=>playNextTrack(true), AUTO_SKIP_DELAY); return; } // [M·ªöI] Skip n·∫øu ID r·ªóng
                    if (audio && audio.src) { /* Reset audio if exists */ }

                     if (!youtubeApiReady) { console.warn("YT API not ready, will load when ready."); if (trackTitleElement) trackTitleElement.textContent="Ch·ªù API..."; return; }

                    // *** [M·ªöI] Set a timeout to handle player load errors ***
                     skipTrackTimeout = setTimeout(() => {
                         console.error(`Timeout: YT Player for track ${index} did not become ready/error out in time. Skipping.`);
                         if (playlist.length > 1) playNextTrack(true); // Skip if possible
                         else disableAllControls(); // Cannot skip
                    }, 8000); // Ch·ªù t·ªëi ƒëa 8 gi√¢y

                    if (youtubePlayer && typeof youtubePlayer.loadVideoById === 'function') {
                         console.log("Reusing YT Player, loading ID:", track.videoId);
                         youtubePlayer.cueVideoById(track.videoId); // Use cueVideoById for explicit control via playAudio() later
                         // 'onStateChange' to CUED or 'onReady' will enable controls / trigger playAudio if playOnReady is true.
                     } else { /* Create new player */ }
                 } else { // url track
                    console.log(`Type: URL, Source: ${track.url}`);
                     if (!track.url) { console.error("Invalid URL for track!"); if(trackTitleElement) trackTitleElement.textContent="L·ªói URL"; currentPlayerType='none'; skipTrackTimeout = setTimeout(()=>playNextTrack(true), AUTO_SKIP_DELAY); return; } // [M·ªöI] Skip n·∫øu URL r·ªóng
                    if (typeof Audio === 'undefined') { /* Handle no Audio support */ }
                     if (youtubePlayer && typeof youtubePlayer.stopVideo === 'function') { /* Stop YT */ }

                     if (!audio) { /* Create Audio Element, Add Listeners, Sync Volume */ }

                    // *** [M·ªöI] Set a timeout for HTML Audio load errors ***
                    skipTrackTimeout = setTimeout(() => {
                        if (audio.readyState < 2) { // Still not ready HAVE_CURRENT_DATA
                            console.error(`Timeout: HTML Audio for track ${index} did not load in time (readyState: ${audio.readyState}). Skipping.`);
                            if (playlist.length > 1) playNextTrack(true); // Skip if possible
                            else disableAllControls();
                         }
                    }, 8000); // Ch·ªù t·ªëi ƒëa 8 gi√¢y

                    try { /* Set audio.src and load */ }
                     catch (e) { /* Handle error, skip track */ skipTrackTimeout = setTimeout(()=>playNextTrack(true), AUTO_SKIP_DELAY); }
                 }
             }

             function addAudioListeners() {
                 if (!audio) return;
                 console.log("Attaching listeners to Audio element.");
                 // --- TIMEUPDATE ---
                 audio.addEventListener('timeupdate', () => { /* Update progress bar and Media Session Position */ });
                 // --- ENDED --- [C·∫¨P NH·∫¨T]
                 audio.addEventListener('ended', () => {
                    if (currentPlayerType === 'url') {
                         console.log("HTML Audio Ended, calling playNextTrack(true)");
                        isPlaying = false; /* Update state before playing next */
                         updateMediaSessionPlaybackState();
                         playNextTrack(true); // true -> request autoplay next
                     }
                 });
                 // --- ERROR --- [C·∫¨P NH·∫¨T]
                 audio.addEventListener('error', (e) => {
                    clearTimeout(skipTrackTimeout); // Clear timeout if error occurs first
                     if (currentPlayerType === 'url') {
                        let m="Err"; if(audio.error){/* map code to msg */} console.error("Audio Err:", m, e);
                        if(trackTitleElement)trackTitleElement.textContent=m;
                         disableAllControls();isPlaying=false;currentPlayerType='none';updatePlayPauseButton(false);container?.classList.remove('is-playing');
                        updateMediaSessionPlaybackState();
                         // *** [M·ªöI] T·ª± ƒë·ªông b·ªè qua b√†i l·ªói ***
                         console.warn(`HTML Audio Error on track ${currentTrackIndex}. Attempting auto-skip in ${AUTO_SKIP_DELAY}ms...`);
                        if (playlist.length > 1) {
                             skipTrackTimeout = setTimeout(() => {
                                 console.log(`Auto-skipping failed HTML Audio track ${currentTrackIndex}...`);
                                 playNextTrack(true);
                             }, AUTO_SKIP_DELAY);
                         } else { console.warn("Cannot skip, only one track."); }
                     }
                 });
                 // --- CANPLAY --- [C·∫¨P NH·∫¨T]
                 audio.addEventListener('canplay', () => {
                     if (currentPlayerType === 'url') {
                         console.log("Audio CanPlay");
                         clearTimeout(skipTrackTimeout); // <<<--- [M·ªöI] H·ªßy timeout b·ªè qua l·ªói n·∫øu load th√†nh c√¥ng
                         if (!audio.error) {
                             enableMainControls(); // B·∫≠t n√∫t ch√≠nh
                             updatePrevNextButtonStates(); // C·∫≠p nh·∫≠t n√∫t prev/next
                             updateAudioPositionState();
                             updateMediaSessionMetadata();
                             setupMediaSessionActions();
                            if (playOnReady) { // << Ki·ªÉm tra c·ªù ·ªü ƒë√¢y
                                 playOnReady = false; // << Reset c·ªù NGAY L·∫¨P T·ª®C
                                 console.log("Audio CanPlay: playOnReady=true -> Calling playAudio()");
                                 playAudio();
                             } else {
                                 // N·∫øu kh√¥ng t·ª± ƒë·ªông ph√°t, ƒë·∫£m b·∫£o tr·∫°ng th√°i l√† paused
                                updateMediaSessionPlaybackState();
                             }
                         } else console.error("Audio CanPlay with error state.");
                     }
                 });
                // --- PAUSE / PLAYING / SEEKED / etc (gi·ªØ nguy√™n nh∆∞ v14) ---
                 audio.addEventListener('pause', () => { if (currentPlayerType === 'url' && isPlaying) { isPlaying = false; updatePlayPauseButton(false); playOnReady = false; container?.classList.remove('is-playing'); updateMediaSessionPlaybackState(); } });
                 audio.addEventListener('playing', () => { if (currentPlayerType === 'url' && !isPlaying) { isPlaying = true; updatePlayPauseButton(true); container?.classList.add('is-playing'); updateMediaSessionPlaybackState(); } });
                audio.addEventListener('seeked', () => { if (currentPlayerType === 'url') { updateAudioPositionState(); } });
                 audio.addEventListener('loadstart', () => { /* Log */ });
             }

             function togglePlayPause() {
                 if (!userHasInteracted) { /* Set interaction flag */ userHasInteracted = true; }
                if (playPauseBtn?.disabled) { /* Attempt to load first track if needed */ if(currentTrackIndex < 0 && playlist.length > 0) loadTrack(0, true); return; }

                 if (isPlaying) {
                     pauseAudio();
                 } else {
                     if (currentTrackIndex < 0 && playlist.length > 0) {
                         // Load track ƒë·∫ßu ti√™n v√† Y√äU C·∫¶U ph√°t khi s·∫µn s√†ng
                         loadTrack(0, true);
                     } else {
                         // ƒê√£ c√≥ track ƒë∆∞·ª£c load (ho·∫∑c ƒëang load), ch·ªâ c·∫ßn y√™u c·∫ßu ph√°t
                        playOnReady = false; // ƒê·∫∑t l·∫°i c·ªù n·∫øu n√≥ ƒëang true t·ª´ tr∆∞·ªõc (√≠t x·∫£y ra)
                        playAudio(); // G·ªçi playAudio tr·ª±c ti·∫øp
                    }
                 }
             }

            // Function playAudio ƒë√£ ƒë∆∞·ª£c ƒëi·ªÅu ch·ªânh ƒë·ªÉ reset playOnReady ngay l·∫≠p t·ª©c
            function playAudio() {
                 // <<< Reset playOnReady immediately >>>
                 const wasPlayOnReady = playOnReady; // Store for logging
                 playOnReady = false;

                 if(playPauseBtn?.disabled) return; // Re-check disabled state

                 console.log(`Attempting to play (Type: ${currentPlayerType}, requested by playOnReady: ${wasPlayOnReady})`);

                 if (currentPlayerType === 'youtube') {
                     if (youtubePlayer && youtubePlayerReady && typeof youtubePlayer.playVideo === 'function') {
                         console.log("CMD: YT playVideo()");
                         youtubePlayer.playVideo();
                     } else {
                         console.warn("Cannot Play YT: Not ready or no player.");
                         // If player exists but isn't ready, set flag to play when ready (should already be handled by loadTrack)
                         if (youtubePlayer && !youtubePlayerReady) {
                             playOnReady = true; // Set flag again just in case
                             console.log("Play called but YT not ready, setting playOnReady=true");
                         } else if (!youtubePlayer && currentTrackIndex >= 0) {
                            console.log("No YT player, trying loadTrack again with play intent");
                             loadTrack(currentTrackIndex, true); // Attempt load again, request play
                         } else {
                             updatePlayPauseButton(false); // Cannot play, ensure button is paused
                         }
                     }
                 } else if (currentPlayerType === 'url') {
                    // Logic play HTML Audio (v·ªõi .catch l·ªói) gi·ªØ nguy√™n nh∆∞ v14...
                    if (!audio || !audio.src) { if (currentTrackIndex >= 0) loadTrack(currentTrackIndex, true); else updatePlayPauseButton(false); return; }
                    if (audio.readyState < 2) { playOnReady = true; if(audio.networkState === 3) loadTrack(currentTrackIndex, true); else if (audio.networkState !== 1) audio.load(); return; }
                    console.log("CMD: Audio play()");
                    const playPromise = audio.play();
                     if (playPromise !== undefined) { /* Handle promise */ }
                } else { /* No player type logic */ }
             }

            // PauseAudio gi·ªØ nguy√™n
            function pauseAudio() { /* gi·ªØ nguy√™n nh∆∞ v14, ƒë·∫£m b·∫£o isPlaying=false, update button/state */ }

            // playNextTrack [C·∫¨P NH·∫¨T]
            function playNextTrack(triggeredByEnd = false) {
                 if (!playlist || playlist.length <= 1) { console.log("Cannot play next: Playlist empty or only one track."); if(triggeredByEnd && playlist.length === 1) { seekToStart(); updatePlayPauseButton(false); updateMediaSessionPlaybackState(); /* Stop after one loop */ } return; }
                if (!nextBtn || nextBtn.disabled && !triggeredByEnd) { console.log("Next button disabled."); return; } // Don't play next if disabled UNLESS triggered by end

                 // Ch·ªâ t·ª± ƒë·ªông ph√°t b√†i ti·∫øp theo n·∫øu n√≥ k·∫øt th√∫c t·ª± nhi√™n (triggeredByEnd=true)
                // Ho·∫∑c n·∫øu ng∆∞·ªùi d√πng ƒëang nghe v√† b·∫•m next (isPlaying=true)
                const shouldAutoplayNext = triggeredByEnd || isPlaying;
                console.log(`Playing Next Track (Index ${currentTrackIndex + 1}), Auto-play: ${shouldAutoplayNext}`);

                 const nextIndex = (currentTrackIndex + 1) % playlist.length;
                 loadTrack(nextIndex, shouldAutoplayNext); // <<< Truy·ªÅn tr·∫°ng th√°i autoplay mong mu·ªën
             }

             // playPrevTrack [C·∫¨P NH·∫¨T]
            function playPrevTrack() {
                 if (!playlist || playlist.length === 0) return;
                 if (!prevBtn || prevBtn.disabled) { console.log("Previous button disabled."); return; }

                const shouldContinuePlay = isPlaying; // Lu√¥n gi·ªØ tr·∫°ng th√°i play/pause hi·ªán t·∫°i khi b·∫•m prev

                 if (shouldContinuePlay && getCurrentPlaybackTime() > 3) {
                     console.log("Playing Previous Track (Restarting Current)");
                     seekToStart();
                    // Play n·∫øu n√≥ ƒëang ph√°t tr∆∞·ªõc khi seek
                     if (isPlaying) {
                        if(currentPlayerType === 'url' && audio.paused) playAudio(); // Play if seek paused it
                         // YT usually keeps playing after seekTo, but check state if needed
                        // else if (currentPlayerType === 'youtube' && youtubePlayer?.getPlayerState() !== YT.PlayerState.PLAYING) playAudio();
                     }
                    return;
                 }

                 console.log(`Playing Previous Track (Index ${currentTrackIndex - 1}), Maintain Play State: ${shouldContinuePlay}`);
                const prevIndex = (currentTrackIndex - 1 + playlist.length) % playlist.length;
                 loadTrack(prevIndex, shouldContinuePlay); // <<< Gi·ªØ tr·∫°ng th√°i play/pause
             }
            function getCurrentPlaybackTime() { /* gi·ªØ nguy√™n */ }
            function seekToStart() { /* gi·ªØ nguy√™n */ }
            if (progressContainer) { progressContainer.addEventListener('click', (e)=>{ /* gi·ªØ nguy√™n logic seek */ }); }
            function enableMainControls() { /* gi·ªØ nguy√™n */ }
            function disableMainControls() { /* gi·ªØ nguy√™n */ }
            function disableAllControls() { /* gi·ªØ nguy√™n */ }
            function updatePrevNextButtonStates() { /* gi·ªØ nguy√™n */ }
            function updatePlayPauseButton(playing) { /* gi·ªØ nguy√™n */ }


            // ======================================================
            // === CLOCK / TODO / ANIME (Logic gi·ªØ nguy√™n, kh√¥ng ƒë·ªïi) ===
            // ======================================================
            // ... (T·∫•t c·∫£ code c·ªßa Clock, Todo, Anime Search/Player gi·ªØ nguy√™n) ...
             function updateClock(){ /*...*/ }
             function scheduleNotification(t){ /*...*/ }
             function showNotification(t){ /*...*/ }
             function renderTask(t){ /*...*/ }
             function renderTasks(){ /*...*/ }
             function saveTasks(){ /*...*/ }
             function loadTasks(){ /*...*/ }
             function addTask(e){ /*...*/ }
             function deleteTask(i){ /*...*/ }
             function toggleCompleteTask(i){ /*...*/ }
             function checkNotificationPermission(s=false){ /*...*/ }
             function handleRequestPermission(){ /*...*/ }
             async function loadAnimeData() { /*...*/ }
             function renderSearchResults(uniqueNames) { /*...*/ }
             function handleSearch() { /*...*/ }
             function handleAnimeSelect(name) { /*...*/ }
             function renderEpisodeList(records) { /*...*/ }
             function handleEpisodePlay(link, epName) { /*...*/ }
             function closePlayer() { /*...*/ }
             function goBackToSearch() { /*...*/ }


            // ============================
            // === INITIALIZATION ===
            // ============================
            console.log("üöÄ Init Profile v15.0 (Autoplay Next Fix & Error Skip)... ‚ú®");
            if (hasMediaSession) { console.log("üéß Media Session API is supported!"); } else { console.warn("‚ö†Ô∏è Media Session API is NOT supported."); }

            setPrimaryColorRGB();
            if (clockElement) { /* init clock */ }
            loadTasks();
            loadAnimeData();
            loadYouTubeAPI(); // <<< Quan tr·ªçng: ph·∫£i g·ªçi API load s·ªõm

            // --- Init Player Listeners ---
             if (playPauseBtn) playPauseBtn.addEventListener('click', togglePlayPause);
             if (nextBtn) nextBtn.addEventListener('click', () => playNextTrack(false)); // false v√¨ ng∆∞·ªùi d√πng b·∫•m n√∫t
             if (prevBtn) prevBtn.addEventListener('click', playPrevTrack);

             // --- Set initial player state ---
             if (playlist && playlist.length > 0) {
                 // B·∫Øt ƒë·∫ßu v·ªõi c√°c n√∫t b·ªã v√¥ hi·ªáu h√≥a, s·∫Ω ƒë∆∞·ª£c b·∫≠t khi s·∫µn s√†ng
                 disableAllControls();
                if(playPauseBtn) playPauseBtn.disabled = false; // << Ch·ªâ n√∫t Play l√† c√≥ th·ªÉ nh·∫•n ban ƒë·∫ßu
                 if (trackTitleElement) trackTitleElement.textContent = "S·∫µn s√†ng ph√°t nh·∫°c";
                 if (hasMediaSession) { setupMediaSessionActions(); }
            } else {
                 if (trackTitleElement) trackTitleElement.textContent = "Playlist tr·ªëng";
                 disableAllControls();
                if(hasMediaSession) { /* Clear session state/handlers */ }
            }

             // --- Init Other Listeners ---
             /* Gi·ªØ nguy√™n c√°c listeners cho Anime, Todo, links, close player */
             if (searchInput) { searchInput.addEventListener('input', handleSearch); /*...*/ }
             if (searchButton) { searchButton.addEventListener('click', /*...*/); }
             if (closePlayerBtn) closePlayerBtn.addEventListener('click', closePlayer);
             /*...*/

            // --- Init Entrance Animations (Kh√¥ng ƒë·ªïi) ---
             try { /*...*/ } catch (e) { /* fallback */ }

             // Init Hover Animations (Kh√¥ng ƒë·ªïi)
             /*...*/

             console.log("‚úÖ Initialization v15.0 complete!");
             if (typeof anime !== 'undefined') console.log("‚ÑπÔ∏è Anime.js v:", anime.version);

         }); // --- DOMContentLoaded End ---
    </script>

</body>
</html>
```

**T√≥m t·∫Øt c√°c thay ƒë·ªïi quan tr·ªçng (v15.0):**

1.  **Logic `playOnReady` (thay cho `playAfterLoad`):** C·ªù n√†y ƒë∆∞·ª£c ƒë·∫∑t khi b·∫°n mu·ªën nh·∫°c ph√°t *ngay khi* n√≥ s·∫µn s√†ng (v√≠ d·ª•: khi b√†i tr∆∞·ªõc k·∫øt th√∫c ho·∫∑c khi ng∆∞·ªùi d√πng nh·∫•n Play l·∫ßn ƒë·∫ßu). N√≥ ƒë∆∞·ª£c reset *ngay l·∫≠p t·ª©c* trong h√†m `playAudio()` ƒë·ªÉ tr√°nh g·ªçi play nhi·ªÅu l·∫ßn.
2.  **Truy·ªÅn tr·∫°ng th√°i Play v√†o `loadTrack()`:** H√†m `loadTrack(index, playWhenReady)` gi·ªù ƒë√¢y nh·∫≠n m·ªôt tham s·ªë th·ª© hai ƒë·ªÉ bi·∫øt c√≥ n√™n ƒë·∫∑t c·ªù `playOnReady` hay kh√¥ng. ƒêi·ªÅu n√†y gi√∫p ki·ªÉm so√°t ch√≠nh x√°c h∆°n vi·ªác t·ª± ƒë·ªông ph√°t b√†i ti·∫øp theo.
3.  **H√†m `playNextTrack(triggeredByEnd)`:** X√°c ƒë·ªãnh `shouldAutoplayNext` d·ª±a tr√™n vi·ªác b√†i h√°t tr∆∞·ªõc k·∫øt th√∫c t·ª± nhi√™n (`triggeredByEnd = true`) hay ng∆∞·ªùi d√πng ƒëang nghe d·ªü v√† b·∫•m next (`isPlaying = true`). Tr·∫°ng th√°i n√†y ƒë∆∞·ª£c truy·ªÅn v√†o `loadTrack`.
4.  **H√†m `playPrevTrack()`:** Lu√¥n gi·ªØ tr·∫°ng th√°i play/pause hi·ªán t·∫°i khi chuy·ªÉn v·ªÅ b√†i tr∆∞·ªõc (`loadTrack(prevIndex, shouldContinuePlay)`).
5.  **X·ª≠ l√Ω l·ªói v√† t·ª± ƒë·ªông b·ªè qua:**
    *   N·∫øu `loadTrack` g·∫∑p l·ªói ngay l·∫≠p t·ª©c (ID/URL r·ªóng) ho·∫∑c trong `onPlayerError` (YouTube) / `error` (Audio), m·ªôt `setTimeout` s·∫Ω ƒë∆∞·ª£c ƒë·∫∑t (`skipTrackTimeout`).
    *   N·∫øu trong kho·∫£ng `AUTO_SKIP_DELAY` (v√≠ d·ª•: 1.5 gi√¢y) m√† b√†i h√°t v·∫´n kh√¥ng kh·∫Øc ph·ª•c ƒë∆∞·ª£c l·ªói (v√≠ d·ª•: kh√¥ng c√≥ s·ª± ki·ªán `onReady` hay `canplay`), h√†m `playNextTrack(true)` s·∫Ω ƒë∆∞·ª£c g·ªçi ƒë·ªÉ th·ª≠ ph√°t b√†i k·∫ø ti·∫øp.
    *   N·∫øu b·∫•t k·ª≥ s·ª± ki·ªán n√†o cho th·∫•y track ƒë√£ s·∫µn s√†ng (`onReady`, `canplay`) ho·∫∑c c√≥ thay ƒë·ªïi tr·∫°ng th√°i (`onStateChange`) x·∫£y ra tr∆∞·ªõc khi timeout, `skipTrackTimeout` s·∫Ω b·ªã h·ªßy.
6.  **H·ªßy Timeout k·ªãp th·ªùi:** `clearTimeout(skipTrackTimeout)` ƒë∆∞·ª£c g·ªçi ·ªü ƒë·∫ßu `loadTrack`, khi player s·∫µn s√†ng (`onReady`, `canplay`), khi c√≥ l·ªói r√µ r√†ng (`onPlayerError`, `audio error`), v√† khi c√≥ state change (`onPlayerStateChange`) ƒë·ªÉ tr√°nh vi·ªác b·ªè qua b√†i h√°t m·ªôt c√°ch kh√¥ng c·∫ßn thi·∫øt.
7.  **B·∫≠t/T·∫Øt Controls:** C√°c n√∫t ƒëi·ªÅu khi·ªÉn ƒë∆∞·ª£c qu·∫£n l√Ω c·∫©n th·∫≠n h∆°n. Ch√∫ng ch·ªâ ƒë∆∞·ª£c b·∫≠t ƒë·∫ßy ƒë·ªß khi track th·ª±c s·ª± s·∫µn s√†ng trong `onPlayerReady`/`canplay`. N√∫t Play ban ƒë·∫ßu ƒë∆∞·ª£c b·∫≠t ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ t∆∞∆°ng t√°c l·∫ßn ƒë·∫ßu.

**V·ªÅ v·∫•n ƒë·ªÅ t·∫Øt m√†n h√¨nh:**

Nh∆∞ ƒë√£ n√≥i, code v15 n√†y v·∫´n gi·ªØ nguy√™n c√°c t·ªëi ∆∞u c·ªßa **Media Session API** t·ª´ v14. N√≥ s·∫Ω gi√∫p hi·ªÉn th·ªã th√¥ng tin v√† ƒëi·ªÅu khi·ªÉn nh·∫°c tr√™n m√†n h√¨nh kh√≥a, v√† *c√≥ th·ªÉ* k√©o d√†i th·ªùi gian ph√°t nh·∫°c n·ªÅn h∆°n. Tuy nhi√™n, vi·ªác nh·∫°c c√≥ d·ª´ng hay kh√¥ng sau m·ªôt th·ªùi gian t·∫Øt m√†n h√¨nh v·∫´n ph·ª• thu·ªôc v√†o **ch√≠nh s√°ch ti·∫øt ki·ªám pin c·ªßa ƒëi·ªán tho·∫°i/tr√¨nh duy·ªát** m√† ch√∫ng ta kh√¥ng th·ªÉ ki·ªÉm so√°t ho√†n to√†n b·∫±ng code web.

H√£y th·ª≠ nghi·ªám phi√™n b·∫£n n√†y nh√©! Hi v·ªçng l·ªói t·ª± ƒë·ªông chuy·ªÉn b√†i s·∫Ω ƒë∆∞·ª£c kh·∫Øc ph·ª•c ho√†n to√†n v√† tr·∫£i nghi·ªám nghe nh·∫°c c·ªßa b·∫°n s·∫Ω li·ªÅn m·∫°ch h∆°n! üí™ Ch√∫c b·∫°n code vui! ‚ú®
